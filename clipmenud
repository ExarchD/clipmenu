#!/bin/bash

# Some people copy/paste huge swathes of text that could slow down dmenu
line_length_limit=500

cache_dir=/tmp/clipmenu.$USER/
mkdir -p -m0700 "$cache_dir"

declare -A last_data

while sleep "${CLIPMENUD_SLEEP:-0.5}"; do
    for selection in clipboard primary; do
        if type -p xsel >/dev/null 2>&1; then
            data=$(xsel --"$selection"; printf x)
            # Take ownership of the clipboard, in case the original application
            # is unable to serve the clipboard request (due to being suspended,
            # etc).
            #
            # Primary is excluded from the change of ownership as applications
            # sometimes act up if clipboard focus is taken away from them --
            # for example, urxvt will unhilight text, which is undesirable.
            if [[ $selection != primary ]]; then
                xsel --"$selection" | xsel -i --"$selection"
            fi
        else
            data=$(xclip -o -sel "$selection"; printf x)
            # See above comments about taking ownership of the clipboard for
            # context.
            if [[ $selection != primary ]]; then
                xclip -o -sel "$selection" | xclip -i -sel "$selection"
            fi
        fi

        # We add and remove the x so that trailing newlines are not stripped.
        # Otherwise, they would be stripped by the very nature of how POSIX
        # defines command substitution.
        data=${data%x}

        [[ $data == *[^[:blank:]]* ]] || continue

        [[ ${last_data[$selection]} == "$data" ]] && continue
        last_data[$selection]=$data

        # We look for the first line matching regex /./ here because we want the
        # first line that can provide reasonable context to the user. That is, if
        # you have 5 leading lines of whitespace, displaying " (6 lines)" is much
        # less useful than displaying "foo (6 lines)", where "foo" is the first
        # line in the entry with actionable context.
        first_line=$(
            sed -n '/./{p;q}' <<< "$data" | cut -c1-"$line_length_limit"
        )
        lines=$(wc -l <<< "$data")

        if (( lines > 1 )); then
            first_line+=" ($lines lines)"
        fi

        filename=$cache_dir/$(LC_ALL=C date +%F-%H-%M-%S)-$first_line
        printf '%s' "$data" > "$filename"
    done
done
